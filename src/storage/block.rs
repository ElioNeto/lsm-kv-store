use crate::infra::config::StorageConfig;\nuse std::mem::size_of;\n\npub const BLOCK_SIZE: usize = 4096;\nconst U32_SIZE: usize = size_of::<u32>();\n\n#[derive(Debug, Clone)]\npub struct Block {\n    pub(crate) data: Vec<u8>,\n    pub(crate) offsets: Vec<u32>,\n    block_size: usize,\n}\n\nimpl Block {\n    pub fn from_config(config: &StorageConfig) -> Self {\n        Self::new(config.block_size)\n    }\n\n    pub fn new(block_size: usize) -> Self {\n        Self {\n            data: Vec::new(),\n            offsets: Vec::new(),\n            block_size,\n        }\n    }\n\n    fn entry_size(key: &[u8], value: &[u8]) -> usize {\n        // KeyLen(2) + Key + ValLen(2) + Value\n        // Note: Using u16 for key/value length storage within the block data \n        // to maintain compactness for individual entries, while allowing \n        // the overall block to be larger than 64KB via u32 offsets.\n        2 + key.len() + 2 + value.len()\n    }\n\n    fn metadata_size(num_entries: usize) -> usize {\n        (num_entries * U32_SIZE) + U32_SIZE\n    }\n\n    fn current_size(&self) -> usize {\n        self.data.len() + Self::metadata_size(self.offsets.len())\n    }\n\n    pub fn add(&mut self, key: &[u8], value: &[u8]) -> bool {\n        let entry_size = Self::entry_size(key, value);\n        let new_offset_size = U32_SIZE;\n        let total_needed = self.current_size() + entry_size + new_offset_size;\n\n        if total_needed > self.block_size {\n            return false;\n        }\n\n        let offset = self.data.len() as u32;\n        self.offsets.push(offset);\n\n        // Cast to u16 is safe for key/value lengths as we assume \n        // individual entries don't exceed 64KB, even if the block does.\n        let key_len = key.len() as u16;\n        let val_len = value.len() as u16;\n\n        self.data.extend_from_slice(&key_len.to_le_bytes());\n        self.data.extend_from_slice(key);\n        self.data.extend_from_slice(&val_len.to_le_bytes());\n        self.data.extend_from_slice(value);\n\n        true\n    }\n\n    pub fn encode(&self) -> Vec<u8> {\n        let mut encoded = Vec::with_capacity(self.current_size());\n        encoded.extend_from_slice(&self.data);\n\n        for &offset in &self.offsets {\n            encoded.extend_from_slice(&offset.to_le_bytes());\n        }\n\n        let num_elements = self.offsets.len() as u32;\n        encoded.extend_from_slice(&num_elements.to_le_bytes());\n\n        encoded\n    }\n\n    pub fn decode(data: &[u8]) -> Self {\n        if data.len() < U32_SIZE {\n            return Self {\n                data: Vec::new(),\n                offsets: Vec::new(),\n                block_size: BLOCK_SIZE,\n            };\n        }\n\n        let num_elements_start = data.len() - U32_SIZE;\n        let num_elements =\n            u32::from_le_bytes([data[num_elements_start], data[num_elements_start + 1], data[num_elements_start + 2], data[num_elements_start + 3]]) as usize;\n\n        let offsets_start = data.len() - U32_SIZE - (num_elements * U32_SIZE);\n        let records_data = data[..offsets_start].to_vec();\n\n        let mut offsets = Vec::with_capacity(num_elements);\n        let mut offset_pos = offsets_start;\n\n        for _ in 0..num_elements {\n            let offset = u32::from_le_bytes([data[offset_pos], data[offset_pos + 1], data[offset_pos + 2], data[offset_pos + 3]]);\n            offsets.push(offset);\n            offset_pos += U32_SIZE;\n        }\n\n        Self {\n            data: records_data,\n            offsets,\n            block_size: BLOCK_SIZE,\n        }\n    }\n\n    pub fn len(&self) -> usize {\n        self.offsets.len()\n    }\n\n    pub fn is_empty(&self) -> bool {\n        self.offsets.is_empty()\n    }\n\n    pub fn data_size(&self) -> usize {\n        self.data.len()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_new_block_is_empty() {\n        let block = Block::new(BLOCK_SIZE);\n        assert_eq!(block.len(), 0);\n        assert!(block.is_empty());\n        assert_eq!(block.data_size(), 0);\n    }\n\n    #[test]\n    fn test_add_single_entry() {\n        let mut block = Block::new(BLOCK_SIZE);\n        let key = b\"test_key\";\n        let value = b\"test_value\";\n        let success = block.add(key, value);\n        assert!(success, \"Should successfully add entry\");\n        assert_eq!(block.len(), 1);\n        assert!(!block.is_empty());\n    }\n\n    #[test]\n    fn test_add_multiple_entries() {\n        let mut block = Block::new(BLOCK_SIZE);\n        for i in 0..10 {\n            let key = format!(\"key_{:03}\", i);\n            let value = format!(\"value_{:03}\", i);\n            let success = block.add(key.as_bytes(), value.as_bytes());\n            assert!(success, \"Should add entry {}\", i);\n        }\n        assert_eq!(block.len(), 10);\n    }\n\n    #[test]\n    fn test_add_until_full() {\n        let mut block = Block::new(256);\n        let mut added_count = 0;\n\n        for i in 0..100 {\n            let key = format!(\"k{}\", i);\n            let value = format!(\"v{}\", i);\n            if block.add(key.as_bytes(), value.as_bytes()) {\n                added_count += 1;\n            } else {\n                break;\n            }\n        }\n\n        assert!(added_count > 0, \"Should have added at least one entry\");\n        assert!(\n            added_count < 100,\n            \"Should not have added all entries (block is full)\"\n        );\n\n        let result = block.add(b\"extra_key\", b\"extra_value\");\n        assert!(!result, \"Should reject entry when block is full\");\n    }\n\n    #[test]\n    fn test_block_overflow_u16() {\n        // Create a block larger than 64KB (u16::MAX is 65535)\n        let block_size = 70_000;\n        let mut block = Block::new(block_size);\n        \n        // Fill with enough data to exceed 64KB\n        // Each entry approx 1024 bytes\n        let val_size = 1000;\n        let large_value = vec![b'x'; val_size];\n        let key_base = \"key\";\n        \n        let mut count = 0;\n        while block.data_size() < 66000 {\n             let key = format!(\"{}{}\", key_base, count);\n             if !block.add(key.as_bytes(), &large_value) {\n                 break;\n             }\n             count += 1;\n        }\n        \n        assert!(block.data_size() > 65535, \"Block data size should be > 64KB\");\n        \n        // Verify integrity\n        let encoded = block.encode();\n        let decoded = Block::decode(&encoded);\n        \n        assert_eq!(decoded.len(), block.len());\n        assert_eq!(decoded.offsets.len(), block.offsets.len());\n        \n        // Verify last entry is correct\n        let last_offset = *decoded.offsets.last().unwrap();\n        assert!(last_offset > 65535, \"Last offset should exceed u16 limit\");\n    }\n\n    #[test]\n    fn test_encode_decode_empty_block() {\n        let block = Block::new(BLOCK_SIZE);\n        let encoded = block.encode();\n        let decoded = Block::decode(&encoded);\n        assert_eq!(decoded.len(), 0);\n        assert!(decoded.is_empty());\n    }\n\n    #[test]\n    fn test_encode_decode_single_entry() {\n        let mut block = Block::new(BLOCK_SIZE);\n        block.add(b\"key1\", b\"value1\");\n        let encoded = block.encode();\n        let decoded = Block::decode(&encoded);\n        assert_eq!(decoded.len(), 1);\n        assert_eq!(decoded.data_size(), block.data_size());\n        assert_eq!(decoded.data, block.data);\n        assert_eq!(decoded.offsets, block.offsets);\n    }\n\n    #[test]\n    fn test_encode_decode_multiple_entries() {\n        let mut block = Block::new(BLOCK_SIZE);\n        let entries = vec![\n            (b\"apple\" as &[u8], b\"red\" as &[u8]),\n            (b\"banana\", b\"yellow\"),\n            (b\"cherry\", b\"red\"),\n            (b\"date\", b\"brown\"),\n            (b\"elderberry\", b\"purple\"),\n        ];\n\n        for (key, value) in &entries {\n            assert!(block.add(key, value));\n        }\n\n        let encoded = block.encode();\n        let decoded = Block::decode(&encoded);\n        assert_eq!(decoded.len(), entries.len());\n        assert_eq!(decoded.data, block.data);\n        assert_eq!(decoded.offsets, block.offsets);\n    }\n}\n